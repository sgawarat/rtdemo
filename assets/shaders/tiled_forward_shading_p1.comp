#version 450

struct Camera {
    mat4 view_proj;
    mat4 view;
    mat4 proj;
    mat4 view_proj_inv;
    mat4 view_inv;
    mat4 proj_inv;
    vec3 position_w;
};
struct TileFrustum {
    vec4 planes_v[4];
};
struct PointLight {
    vec3 position_w;
    float radius;
    vec3 color;
    float intensity;
};
struct GridCell {
    uint first;
    uint count;
};

layout(binding = 0) uniform CameraUniform {
    Camera CAMERA;
};

layout(binding = 0) buffer LightBuffer {
    PointLight LIGHTS[];
};
// layout(binding = 1) buffer FrustumBuffer {
//     FrustumSide FRASTA[];
// }

layout(binding = 10) buffer LightGridBuffer {
    GridCell GRID_CELLS[];
};
layout(binding = 11) buffer LightIndexBuffer {
    uint LIGHT_INDEX_COUNT;
    uint LIGHT_INDICES[];
};

layout(binding = 0) uniform sampler2D DEPTH;

// in uvec3 gl_NumWorkGroups;
// in uvec3 gl_WorkGroupID;
// in uvec3 gl_LocalInvocationID;
// in uvec3 gl_GlobalInvocationID;
// in uint gl_LocalInvocationIndex;

// const uvec3 gl_WorkGroupSize;

shared TileFrustum tile_frustum;
shared uint min_depth_uint;
shared uint max_depth_uint;
shared uint light_indices[1024];
shared uint light_first;
shared uint light_count;

vec4 to_clip(uvec2 group_id) {
    vec2 position_c = vec2(group_id) / vec2(gl_NumWorkGroups.xy) * 2 - vec2(1);
    return vec4(position_c, 1, 1);
}

TileFrustum calc_tile_frustum(uvec2 group_id) {
    vec4 lt = CAMERA.proj_inv * to_clip(group_id + uvec2(0, 0));
    vec4 rt = CAMERA.proj_inv * to_clip(group_id + uvec2(1, 0));
    vec4 lb = CAMERA.proj_inv * to_clip(group_id + uvec2(0, 1));
    vec4 rb = CAMERA.proj_inv * to_clip(group_id + uvec2(1, 1));
    lt /= lt.w;
    rt /= rt.w;
    lb /= lb.w;
    rb /= rb.w;

    TileFrustum frustum;
    frustum.planes_v[0] = vec4(normalize(cross(lt.xyz, lb.xyz)), 0);
    frustum.planes_v[1] = vec4(normalize(cross(rb.xyz, rt.xyz)), 0);
    frustum.planes_v[2] = vec4(normalize(cross(rt.xyz, lt.xyz)), 0);
    frustum.planes_v[3] = vec4(normalize(cross(lb.xyz, rb.xyz)), 0);
    return frustum;
}

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
void main() {
    if (gl_GlobalInvocationID == uvec3(0)) {
        LIGHT_INDEX_COUNT = 0;
    }

    groupMemoryBarrier();

    if (gl_LocalInvocationIndex == 0) {
        tile_frustum = calc_tile_frustum(gl_WorkGroupID.xy);
        min_depth_uint = 1065353216; // = 1.0
        max_depth_uint = 0;
        light_count = 0;
    }

    groupMemoryBarrier();

    float depth = texelFetch(DEPTH, ivec2(gl_GlobalInvocationID.xy), 0).r;
    uint depth_uint = floatBitsToUint(depth);
    atomicMin(min_depth_uint, depth_uint);
    atomicMax(max_depth_uint, depth_uint);

    groupMemoryBarrier();

    vec4 min_depth_v = CAMERA.proj_inv * vec4(0, 0, uintBitsToFloat(min_depth_uint) * 2 - 1, 1);
    vec4 max_depth_v = CAMERA.proj_inv * vec4(0, 0, uintBitsToFloat(max_depth_uint) * 2 - 1, 1);
    float min_depth = min_depth_v.z / min_depth_v.w;
    float max_depth = max_depth_v.z / max_depth_v.w;

    float disp_x = 0;
    float disp_y = 0;
    for (uint i = gl_LocalInvocationIndex; i < LIGHTS.length(); i += 32 * 32) {
        PointLight LIGHT = LIGHTS[i];
        vec4 light_position_v = CAMERA.view * vec4(LIGHT.position_w, 1);
        float dist = dot(light_position_v, tile_frustum.planes_v[3]);
        disp_x = min_depth;//light_position_v.z;
        disp_y = max_depth;
        if (
            // dot(light_position_v, tile_frustum.planes_v[0]) < LIGHT.radius &&
            // dot(light_position_v, tile_frustum.planes_v[1]) < LIGHT.radius &&
            // dot(light_position_v, tile_frustum.planes_v[2]) < LIGHT.radius &&
            // dot(light_position_v, tile_frustum.planes_v[3]) < LIGHT.radius &&
            // light_position_v.z - LIGHT.radius < min_depth &&
            light_position_v.z + LIGHT.radius > max_depth
            ) {
            uint offset = atomicAdd(light_count, 1);
            if (offset < light_indices.length()) {
                light_indices[offset] = i;
            }
        }
    }

    groupMemoryBarrier();

    if (gl_LocalInvocationIndex == 0) {
    uint tile_index = gl_NumWorkGroups.x * gl_WorkGroupID.y + gl_WorkGroupID.x;
        light_first = atomicAdd(LIGHT_INDEX_COUNT, light_count);
        //GRID_CELLS[tile_index] = GridCell(light_first, light_count);
        GRID_CELLS[tile_index] = GridCell(floatBitsToUint(disp_x), floatBitsToUint(disp_y));
    }

    groupMemoryBarrier();

    for (uint i = gl_LocalInvocationIndex; i < light_count; i += 32 * 32) {
        LIGHT_INDICES[light_first + i] = light_indices[i];
    }
}
